import * as THREE from "https://cdn.jsdelivr.net";
import { OrbitControls } from "https://cdn.jsdelivr.net";

// Чекаємо, поки сторінка завантажиться
window.addEventListener('DOMContentLoaded', () => {
    const viewer = document.getElementById("viewer");
    if (!viewer) return;

    // ---------- UI ЭЛЕМЕНТЫ ----------
    const w = document.getElementById("w"), d = document.getElementById("d"), h = document.getElementById("h"), mat = document.getElementById("mat");
    const wVal = document.getElementById("wVal"), dVal = document.getElementById("dVal"), hVal = document.getElementById("hVal"), priceEl = document.getElementById("price");

    // ---------- СЦЕНА THREE.JS ----------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf2f2f2);

    const camera = new THREE.PerspectiveCamera(45, viewer.clientWidth / viewer.clientHeight, 1, 10000);
    camera.position.set(2000, 1500, 2000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(viewer.clientWidth, 500); // Фіксуємо висоту 500px
    viewer.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.5));

    let shelf;

    function buildShelf() {
        if (shelf) scene.remove(shelf);

        // Масштабуємо розміри для візуалізації (ділимо на 10 для зручності)
        const geo = new THREE.BoxGeometry(+w.value, +h.value, +d.value);
        const color = mat.value === "mdf" ? 0xc9a26a : 0xb0b0b0;
        const mat3d = new THREE.MeshStandardMaterial({ color, roughness: 0.7 });
        
        shelf = new THREE.Mesh(geo, mat3d);
        shelf.position.y = +h.value / 2;
        scene.add(shelf);
    }

    function calcPrice() {
        const area = (w.value * d.value * h.value) / 1_000_000_000;
        const base = mat.value === "mdf" ? 15000 : 10000;
        return Math.round(area * base + 500); 
    }

    function update() {
        wVal.textContent = w.value;
        dVal.textContent = d.value;
        hVal.textContent = h.value;
        priceEl.textContent = calcPrice();
        buildShelf();
    }

    [w, d, h, mat].forEach(el => el.oninput = update);
    
    update();

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
    animate();

    // Оновлення розміру при зміні вікна
    window.addEventListener('resize', () => {
        camera.aspect = viewer.clientWidth / 500;
        camera.updateProjectionMatrix();
        renderer.setSize(viewer.clientWidth, 500);
    });
});
